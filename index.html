<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RegexGen - Pattern Builder</title>
    <!-- Ready for Topics: Collections of patterns will be added as a new panel -->
    <style>
        :root {
            --verint-blue: #0066CC;
            --verint-light-blue: #E6F2FF;
            --verint-dark-blue: #004499;
            --verint-gray: #666666;
            --verint-light-gray: #F5F5F5;
            --accent-green: #28a745;
            --accent-orange: #fd7e14;
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f8f9fa;
            color: #333;
        }

        .header {
            background-color: var(--verint-blue);
            color: white;
            padding: 1rem 2rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            margin: 0;
            font-size: 1.5rem;
            font-weight: 500;
        }


        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 2rem 2rem 0;
        }

        .text-input-section {
            margin-bottom: 2rem;
        }

        /* Tab Navigation */
        .tab-navigation {
            display: flex;
            gap: 0;
            margin-bottom: 0;
        }

        .tab-button {
            flex: 1;
            padding: 1rem 2rem;
            background: white;
            border: 1px solid #ddd;
            border-bottom: none;
            border-radius: 8px 8px 0 0;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            color: var(--verint-gray);
        }

        .tab-button:not(.active):hover {
            background: var(--verint-light-gray);
        }

        .tab-button.active {
            background: var(--verint-blue);
            color: white;
            font-weight: 600;
            border-color: var(--verint-blue);
        }

        /* Tab Content */
        .tab-content {
            background: white;
            border-radius: 0 0 8px 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            min-height: 600px;
        }

        .tab-panel {
            display: none;
            padding: 2rem;
        }

        .tab-panel.active {
            display: grid;
            grid-template-columns: 1fr 500px;
            gap: 2rem;
        }

        .main-panel {
            background: white;
            border-radius: 8px;
            padding: 1.5rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .side-panel {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .panel {
            background: white;
            border-radius: 8px;
            padding: 1.5rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .panel-header {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--verint-dark-blue);
        }

        #textInput {
            width: 100%;
            min-height: 400px;
            padding: 1rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            resize: vertical;
            transition: border-color 0.2s;
            line-height: 1.6;
            white-space: pre-wrap;
            position: relative;
        }

        #textInput:focus {
            outline: none;
            border-color: var(--verint-blue);
        }

        .text-display {
            position: relative;
            min-height: 400px;
            padding: 1rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            line-height: 1.6;
            background: #fafafa;
            cursor: text;
            user-select: none;
            overflow-y: auto;
            max-height: 600px;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .edit-button {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            padding: 0.25rem 0.75rem;
            font-size: 12px;
            background: white;
            border: 1px solid var(--verint-blue);
            color: var(--verint-blue);
            cursor: pointer;
            border-radius: 4px;
        }

        .edit-button:hover {
            background: var(--verint-light-blue);
        }

        .clear-text-button {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            width: 30px;
            height: 30px;
            padding: 0;
            background: white;
            border: 1px solid #ddd;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            color: #666;
            transition: all 0.2s;
        }

        .clear-text-button:hover {
            background: #f5f5f5;
            color: #333;
            border-color: #999;
        }

        .word-span {
            padding: 2px;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-block;
            position: relative;
        }

        .word-span:hover {
            background-color: #e0e0e0;
            border-radius: 3px;
        }

        .word-span.selected {
            background-color: var(--verint-light-blue);
            border-radius: 3px;
            font-weight: 600;
        }

        .phrase-selection {
            background-color: var(--verint-light-blue);
            border-radius: 3px;
            font-weight: 600;
            padding: 2px 4px;
            position: relative;
            display: inline;
        }

        .phrase-selection::after {
            content: "✓";
            position: absolute;
            top: -18px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--accent-green);
            color: white;
            padding: 2px 6px;
            border-radius: 50%;
            font-size: 12px;
            font-weight: bold;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .word-span.in-phrase {
            background-color: transparent;
            font-weight: inherit;
        }

        .pattern-preview {
            margin-top: 1rem;
            padding: 1rem;
            background-color: #f8f9fa;
            border-radius: 4px;
            min-height: 60px;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .pattern-element {
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 500;
        }

        .pattern-word {
            background-color: var(--verint-blue);
            color: white;
        }

        .pattern-gap {
            background-color: var(--accent-orange);
            color: white;
            font-style: italic;
        }

        .pattern-phrase {
            background-color: var(--verint-dark-blue);
            color: white;
        }

        .pattern-and {
            background-color: transparent;
            color: var(--verint-gray);
            border: 2px solid var(--verint-gray);
            font-weight: bold;
            font-size: 12px;
        }

        .controls {
            margin-top: 1rem;
            display: flex;
            gap: 1rem;
            align-items: flex-end;
        }

        .input-group {
            flex: 1;
        }

        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: var(--verint-gray);
        }

        input[type="text"] {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            transition: border-color 0.2s;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: var(--verint-blue);
        }

        button {
            background-color: var(--verint-blue);
            color: white;
            border: none;
            padding: 0.5rem 1.5rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background-color 0.2s;
        }

        button:hover {
            background-color: var(--verint-dark-blue);
        }

        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        .button-secondary {
            background-color: white;
            color: var(--verint-blue);
            border: 1px solid var(--verint-blue);
        }

        .button-secondary:hover {
            background-color: var(--verint-light-blue);
        }

        .patterns-list {
            max-height: 400px;
            overflow-y: auto;
        }

        .pattern-item {
            padding: 1rem;
            border: 1px solid #eee;
            border-radius: 4px;
            margin-bottom: 0.75rem;
            transition: all 0.2s;
        }

        .pattern-item:hover {
            background-color: var(--verint-light-gray);
            border-color: var(--verint-blue);
        }

        .pattern-name {
            font-weight: 600;
            color: var(--verint-dark-blue);
            margin-bottom: 0.5rem;
        }

        .pattern-visualization {
            display: flex;
            flex-wrap: wrap;
            gap: 0.25rem;
            margin: 0.5rem 0;
        }

        .pattern-element-small {
            padding: 0.25rem 0.5rem;
            border-radius: 12px;
            font-size: 12px;
        }

        .pattern-regex {
            font-family: monospace;
            font-size: 12px;
            color: var(--verint-gray);
            margin-top: 0.5rem;
            padding: 0.5rem;
            background: #f5f5f5;
            border-radius: 4px;
            word-break: break-all;
        }

        .pattern-actions {
            margin-top: 0.5rem;
            display: flex;
            gap: 0.5rem;
        }

        .button-small {
            padding: 0.25rem 0.75rem;
            font-size: 12px;
        }

        .button-danger {
            background-color: #dc3545;
        }

        .button-danger:hover {
            background-color: #c82333;
        }

        .status-message {
            margin-bottom: 1rem;
            padding: 0.75rem;
            border-radius: 4px;
            font-size: 14px;
            display: none;
        }

        .status-success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status-error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .match-highlight {
            background-color: #FFEB3B;
            padding: 2px;
            border-radius: 2px;
            font-weight: bold;
        }

        .instructions {
            background: var(--verint-light-gray);
            padding: 1rem;
            border-radius: 4px;
            margin-bottom: 1rem;
            font-size: 14px;
        }

        .instructions h3 {
            margin-top: 0;
            color: var(--verint-dark-blue);
        }

        /* Pattern Selector for Topics */
        .patterns-selector {
            max-height: 400px;
            overflow-y: auto;
        }

        .pattern-selector-card {
            border: 2px solid #eee;
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
            transition: all 0.2s;
            cursor: pointer;
        }

        .pattern-selector-card:hover {
            border-color: #ccc;
        }

        .pattern-selector-card.selected {
            border-color: var(--verint-blue);
            background: var(--verint-light-blue);
        }

        .pattern-operator-buttons {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .operator-button {
            padding: 0.25rem 0.75rem;
            font-size: 12px;
            border: 1px solid #ddd;
            background: white;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
            position: relative;
        }

        /* Muted styling for non-active buttons */
        .operator-button:not(.active-and):not(.active-not) {
            background: #f8f9fa;
            color: #999;
            border-color: #e0e0e0;
        }

        .operator-button:hover:not(.active-and):not(.active-not) {
            background: #e9ecef;
            color: #666;
            border-color: #ccc;
        }

        /* AND button styles */
        .operator-button.active-and {
            background: var(--accent-green);
            color: white;
            border-color: var(--accent-green);
            font-weight: 600;
        }

        .operator-button:not(.active-and):first-child {
            color: #28a745;
            background: #f0f9f0;
            border-color: #c3e6c3;
        }

        /* NOT button styles */
        .operator-button.active-not {
            background: #dc3545;
            color: white;
            border-color: #dc3545;
            font-weight: 600;
        }

        .operator-button:not(.active-not):last-child {
            color: #dc3545;
            background: #fdf0f0;
            border-color: #f5c6cb;
        }

        /* Topic Builder */
        .topic-builder {
            margin-top: 1rem;
        }

        #selectedPatternsPreview {
            padding: 1rem;
            background: var(--verint-light-gray);
            border-radius: 4px;
            min-height: 60px;
        }

        .selected-pattern-item {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            margin: 0.25rem;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 500;
        }

        .selected-pattern-and {
            background: var(--accent-green);
            color: white;
        }

        .selected-pattern-not {
            background: #dc3545;
            color: white;
        }

        /* Topics List */
        .topics-list {
            max-height: 400px;
            overflow-y: auto;
        }

        .topic-item {
            padding: 1rem;
            border: 1px solid #eee;
            border-radius: 4px;
            margin-bottom: 0.75rem;
            transition: all 0.2s;
        }

        .topic-item:hover {
            background-color: var(--verint-light-gray);
            border-color: var(--verint-blue);
        }

        .topic-name {
            font-weight: 600;
            color: var(--verint-dark-blue);
            margin-bottom: 0.5rem;
        }

        .topic-patterns {
            font-size: 12px;
            color: var(--verint-gray);
            margin-top: 0.5rem;
        }

        /* Export Tab Styles */
        .exportable-topics-list {
            max-height: 500px;
            overflow-y: auto;
        }

        .export-topic-item {
            border: 2px solid #eee;
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
            transition: all 0.2s;
            cursor: pointer;
        }

        .export-topic-item:hover {
            border-color: #ccc;
        }

        .export-topic-item.selected {
            border-color: var(--verint-blue);
            background: var(--verint-light-blue);
        }


        .export-controls {
            margin-bottom: 1rem;
        }

        .export-actions {
            display: flex;
            gap: 0.5rem;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>RegexGen - Pattern Builder</h1>
    </div>

    <div class="container">
        <!-- Shared text input section -->
        <div class="text-input-section">
            <div class="panel">
                <div class="panel-header">Text Input</div>
                
                <div class="instructions">
                    <h3>How to use:</h3>
                    <p id="instructionText">Click words to select them. Adjacent selections become phrases. Non-adjacent selections create AND patterns that match both parts with anything in between.</p>
                </div>

                <div style="position: relative;">
                    <textarea id="textInput" placeholder="Paste or type your text here..."></textarea>
                    <button class="clear-text-button" onclick="window.clearText()" title="Clear text">✕</button>
                </div>
                <div id="textDisplay" class="text-display" style="display: none;">
                    <span style="color: #999;">Paste or type your text here...</span>
                </div>
            </div>
        </div>

        <!-- Tab navigation -->
        <div class="tab-navigation">
            <button class="tab-button active" onclick="switchTab('patterns')">Patterns</button>
            <button class="tab-button" onclick="switchTab('topics')">Topics</button>
            <button class="tab-button" onclick="switchTab('export')">Export</button>
        </div>

        <!-- Tab content -->
        <div class="tab-content">
            <!-- Patterns Tab -->
            <div id="patternsTab" class="tab-panel active">
                <div class="main-panel">
                    <div class="pattern-preview" id="patternPreview">
                        <span style="color: #999;">Your pattern will appear here as you select words...</span>
                    </div>

                    <div class="controls">
                        <div class="input-group">
                            <label for="patternName">Pattern Name</label>
                            <input type="text" id="patternName" placeholder="Enter pattern name">
                        </div>
                        <button id="savePatternBtn" onclick="savePattern()">Save Pattern</button>
                        <button class="button-secondary" onclick="clearSelections()">Clear Selections</button>
                    </div>
                </div>

                <div class="side-panel">
                    <div class="panel">
                        <div class="panel-header">Saved Patterns</div>
                        <div class="patterns-list" id="patternsList">
                            <!-- Patterns will be listed here -->
                        </div>
                    </div>

                    <div class="panel">
                        <div class="panel-header">Test Results</div>
                        <div id="statusMessage" class="status-message"></div>
                        <div id="testResults" style="display: none;">
                            <div id="testResultsContent"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Topics Tab -->
            <div id="topicsTab" class="tab-panel">
                <div class="main-panel">
                    <div class="panel">
                        <div class="panel-header">Select Patterns to Combine</div>
                        <div class="patterns-selector" id="patternsSelector">
                            <!-- Pattern selection cards will be added here -->
                        </div>
                    </div>

                    <div class="topic-builder panel" id="topicBuilder">
                        <div class="panel-header">Topic Builder</div>
                        <div id="selectedPatternsPreview">
                            <span style="color: #999;">Select patterns above to build a topic...</span>
                        </div>
                        <div class="controls" style="margin-top: 1rem;">
                            <div class="input-group">
                                <label for="topicName">Topic Name</label>
                                <input type="text" id="topicName" placeholder="Enter topic name">
                            </div>
                            <button onclick="window.saveTopic()">Create Topic</button>
                            <button class="button-secondary" onclick="window.clearTopicBuilder()">Clear</button>
                        </div>
                    </div>
                </div>

                <div class="side-panel">
                    <div class="panel">
                        <div class="panel-header">Saved Topics</div>
                        <div class="topics-list" id="topicsList">
                            <!-- Topics will be listed here -->
                        </div>
                    </div>

                    <div class="panel">
                        <div class="panel-header">Test Results</div>
                        <div id="topicStatusMessage" class="status-message"></div>
                        <div id="topicTestResults" style="display: none;">
                            <div id="topicTestResultsContent"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Export Tab -->
            <div id="exportTab" class="tab-panel">
                <div class="main-panel">
                    <div class="panel">
                        <div class="panel-header">Export Topics</div>
                        <div class="export-controls">
                            <input type="text" id="topicSearch" placeholder="Search topics..." onkeyup="filterExportTopics()" style="width: 100%; margin-bottom: 1rem;">
                            <div class="export-actions" style="margin-bottom: 1rem;">
                                <button class="button-secondary" onclick="selectAllTopics()">Select All</button>
                                <button class="button-secondary" onclick="deselectAllTopics()">Clear All</button>
                                <button id="exportButton" onclick="exportSelectedTopics()" disabled>Export to File</button>
                            </div>
                        </div>
                        <div class="exportable-topics-list" id="exportableTopicsList">
                            <!-- Topics for export will be listed here -->
                        </div>
                    </div>
                </div>

                <div class="side-panel">
                    <div class="panel">
                        <div class="panel-header">Export Preview</div>
                        <div id="exportPreview" style="font-family: monospace; font-size: 12px; background: #f5f5f5; padding: 1rem; border-radius: 4px; max-height: 400px; overflow-y: auto;">
                            <span style="color: #999;">Select topics to see export preview...</span>
                        </div>
                        <div style="margin-top: 1rem;">
                            <button class="button-secondary" onclick="copyExportToClipboard()" style="width: 100%;">Copy to Clipboard</button>
                        </div>
                    </div>

                    <div class="panel">
                        <div class="panel-header">Export Format</div>
                        <div style="padding: 0.5rem; background: #f5f5f5; border-radius: 4px; font-size: 12px;">
                            <pre style="margin: 0; white-space: pre-wrap;">{
  "topics": [
    {
      "name": "Topic Name",
      "composed_regex": "^(?=.*pattern1)(?!.*pattern2).*$",
      "components": [
        {
          "pattern": "pattern1",
          "operator": "AND",
          "regex": "\\bword1\\b.*?\\bword2\\b"
        }
      ]
    }
  ]
}</pre>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        import init, { PatternBuilder, get_word_at_position, get_words_from_text } from './pkg/regexgen_rs.js';

        let builder;
        let wordElements = [];
        let selectedWords = [];
        let selectedPatternsForTopic = new Map(); // pattern_id -> {pattern, operator}
        let currentTab = 'patterns';
        let selectedTopicsForExport = new Set(); // Set of topic indices
        let currentExportData = null;

        async function run() {
            await init();
            builder = new PatternBuilder();
            setupTextInput();
            loadPatterns();
            loadTopics();
        }

        function setupTextInput() {
            const textInput = document.getElementById('textInput');
            const textDisplay = document.getElementById('textDisplay');
            
            // Load saved text from localStorage
            const savedText = localStorage.getItem('regexgen_input_text');
            if (savedText) {
                textInput.value = savedText;
                renderTextWithWords(savedText);
            }
            
            // Update display when text changes
            textInput.addEventListener('input', (e) => {
                const text = e.target.value;
                renderTextWithWords(text);
                // Save to localStorage
                localStorage.setItem('regexgen_input_text', text);
            });

            // Handle paste events
            textInput.addEventListener('paste', (e) => {
                setTimeout(() => {
                    const text = textInput.value;
                    renderTextWithWords(text);
                    // Save to localStorage
                    localStorage.setItem('regexgen_input_text', text);
                }, 0);
            });

            // Allow clicking on display to focus hidden textarea
            textDisplay.addEventListener('click', (e) => {
                if (e.target === textDisplay) {
                    textInput.focus();
                }
            });

            // Also handle paste on the display div
            textDisplay.addEventListener('paste', (e) => {
                e.preventDefault();
                const text = (e.clipboardData || window.clipboardData).getData('text');
                textInput.value = text;
                renderTextWithWords(text);
                // Save to localStorage
                localStorage.setItem('regexgen_input_text', text);
            });
        }

        function renderTextWithWords(text) {
            const textInput = document.getElementById('textInput');
            const textDisplay = document.getElementById('textDisplay');
            
            if (!text.trim()) {
                // Show textarea when empty
                textInput.style.display = 'block';
                textDisplay.style.display = 'none';
                return;
            }

            // Hide textarea and show display when there's text
            textInput.style.display = 'none';
            textDisplay.style.display = 'block';

            // Get all words with their positions
            const words = get_words_from_text(text);
            wordElements = words;
            
            // Group consecutive selections into phrases
            const selectedIndices = new Set(selectedWords.map(w => w.word_index));
            const phraseGroups = [];
            let currentPhrase = null;
            
            selectedWords.sort((a, b) => a.word_index - b.word_index).forEach(word => {
                if (currentPhrase && word.word_index === currentPhrase.endIndex + 1) {
                    // Extend current phrase
                    currentPhrase.endIndex = word.word_index;
                    currentPhrase.words.push(word);
                } else {
                    // Start new phrase
                    currentPhrase = {
                        startIndex: word.word_index,
                        endIndex: word.word_index,
                        words: [word]
                    };
                    phraseGroups.push(currentPhrase);
                }
            });
            
            // Build HTML with clickable words
            let html = '<button class="edit-button" onclick="window.editText()">Edit Text</button>';
            html += '<button class="clear-text-button" onclick="window.clearText()" title="Clear text">✕</button>';
            let lastEnd = 0;
            let inPhrase = false;
            let currentPhraseGroup = null;
            
            words.forEach((word, index) => {
                // Check if we're starting a phrase
                const phraseGroup = phraseGroups.find(p => p.startIndex === word.word_index);
                if (phraseGroup) {
                    currentPhraseGroup = phraseGroup;
                    inPhrase = true;
                    
                    // Add non-word text before phrase
                    if (word.start_index > lastEnd) {
                        html += escapeHtml(text.substring(lastEnd, word.start_index));
                    }
                    
                    // Start phrase span
                    html += '<span class="phrase-selection">';
                }
                
                // Add non-word text before this word (if not in phrase)
                if (!inPhrase && word.start_index > lastEnd) {
                    const nonWordText = text.substring(lastEnd, word.start_index);
                    html += escapeHtml(nonWordText);
                }
                
                // Add the word
                const isSelected = selectedIndices.has(word.word_index);
                const isInPhrase = inPhrase && currentPhraseGroup && word.word_index <= currentPhraseGroup.endIndex;
                
                if (isInPhrase) {
                    html += `<span class="word-span in-phrase" 
                             data-word-index="${word.word_index}"
                             onclick="window.handleWordClick(${word.word_index})">${escapeHtml(word.text)}</span>`;
                    
                    // Check if phrase ends
                    if (word.word_index === currentPhraseGroup.endIndex) {
                        // Add any trailing non-word text before closing phrase
                        const nextWord = words[index + 1];
                        if (nextWord && nextWord.start_index > word.end_index) {
                            html += escapeHtml(text.substring(word.end_index, nextWord.start_index));
                            lastEnd = nextWord.start_index;
                        }
                        html += '</span>'; // Close phrase span
                        inPhrase = false;
                        currentPhraseGroup = null;
                    } else {
                        // Add space between words in phrase
                        const nextWord = words[index + 1];
                        if (nextWord && word.end_index < nextWord.start_index) {
                            html += escapeHtml(text.substring(word.end_index, nextWord.start_index));
                            lastEnd = nextWord.start_index;
                        }
                    }
                } else {
                    html += `<span class="word-span ${isSelected && !isInPhrase ? 'selected' : ''}" 
                             data-word-index="${word.word_index}"
                             onclick="window.handleWordClick(${word.word_index})">${escapeHtml(word.text)}</span>`;
                }
                
                lastEnd = word.end_index;
            });
            
            // Add any remaining text
            if (lastEnd < text.length) {
                html += escapeHtml(text.substring(lastEnd));
            }
            
            textDisplay.innerHTML = html;
            textInput.value = text;
        }

        window.handleWordClick = function(wordIndex) {
            const word = wordElements[wordIndex];
            if (!word) return;
            
            // Check if word is already selected
            const existingIndex = selectedWords.findIndex(s => s.word_index === wordIndex);
            
            if (existingIndex >= 0) {
                    // If clicking on a selected word in a phrase, remove the entire phrase
                    const sortedWords = [...selectedWords].sort((a, b) => a.word_index - b.word_index);
                    let removeFrom = existingIndex;
                    let removeTo = existingIndex;
                    
                    // Find start of phrase
                    for (let i = existingIndex - 1; i >= 0; i--) {
                        if (sortedWords[i].word_index === sortedWords[i + 1].word_index - 1) {
                            removeFrom = i;
                        } else {
                            break;
                        }
                    }
                    
                    // Find end of phrase
                    for (let i = existingIndex + 1; i < sortedWords.length; i++) {
                        if (sortedWords[i].word_index === sortedWords[i - 1].word_index + 1) {
                            removeTo = i;
                        } else {
                            break;
                        }
                    }
                    
                    // Remove the phrase
                    const indicesToRemove = new Set();
                    for (let i = removeFrom; i <= removeTo; i++) {
                        indicesToRemove.add(sortedWords[i].word_index);
                    }
                    
                    selectedWords = selectedWords.filter(w => !indicesToRemove.has(w.word_index));
                    
                    // Clear selections from builder and re-add remaining
                    builder.clear_selections();
                    selectedWords.forEach(w => {
                        builder.add_selection(w.text, w.start_index, w.end_index, w.word_index);
                    });
                } else {
                    // Add new selection
                    selectedWords.push(word);
                    builder.add_selection(word.text, word.start_index, word.end_index, word.word_index);
                }
                
            // Re-render to update selection display
            renderTextWithWords(document.getElementById('textInput').value);
            updatePatternPreview();
        };

        function updatePatternPreview() {
            const previewEl = document.getElementById('patternPreview');
            
            // If no selections, show the placeholder
            if (selectedWords.length === 0) {
                previewEl.innerHTML = '<span style="color: #999;">Your pattern will appear here as you select words...</span>';
                return;
            }
            
            // Build the preview from our selected words
            let html = '';
            const sortedWords = [...selectedWords].sort((a, b) => a.word_index - b.word_index);
            
            let i = 0;
            while (i < sortedWords.length) {
                const word = sortedWords[i];
                let phraseWords = [word];
                
                // Check for adjacent words to create phrases
                let j = i + 1;
                while (j < sortedWords.length && sortedWords[j].word_index === sortedWords[j - 1].word_index + 1) {
                    phraseWords.push(sortedWords[j]);
                    j++;
                }
                
                // Add the word or phrase to preview
                if (phraseWords.length > 1) {
                    const phraseText = phraseWords.map(w => w.text).join(' ');
                    html += `<div class="pattern-element pattern-phrase">"${escapeHtml(phraseText)}"</div>`;
                } else {
                    html += `<div class="pattern-element pattern-word">${escapeHtml(word.text)}</div>`;
                }
                
                // Add AND separator if there's a gap before the next selection
                if (j < sortedWords.length) {
                    html += `<div class="pattern-element pattern-and">AND</div>`;
                }
                
                i = j;
            }
            
            previewEl.innerHTML = html;
        }

        window.savePattern = async function() {
            const patternName = document.getElementById('patternName').value.trim();
            
            if (!patternName) {
                showStatus('Please enter a pattern name', 'error');
                return;
            }
            
            if (selectedWords.length === 0) {
                showStatus('Please select at least one word', 'error');
                return;
            }
            
            try {
                const regex = await builder.build_sequence_pattern(patternName);
                showStatus(`Pattern "${patternName}" saved successfully!`, 'success');
                document.getElementById('patternName').value = '';
                selectedWords = [];
                renderTextWithWords(document.getElementById('textInput').value);
                updatePatternPreview();
                loadPatterns();
                // Hide test results when saving a new pattern
                document.getElementById('testResults').style.display = 'none';
            } catch (error) {
                showStatus('Error saving pattern: ' + error, 'error');
            }
        };

        window.clearSelections = function() {
            selectedWords = [];
            builder.clear_selections();
            renderTextWithWords(document.getElementById('textInput').value);
            updatePatternPreview();
        };

        window.editText = function() {
            const textInput = document.getElementById('textInput');
            const textDisplay = document.getElementById('textDisplay');
            
            textInput.style.display = 'block';
            textDisplay.style.display = 'none';
            textInput.focus();
            
            // Clear selections when editing
            clearSelections();
        };

        window.clearText = function() {
            const textInput = document.getElementById('textInput');
            const textDisplay = document.getElementById('textDisplay');
            
            // Clear the text
            textInput.value = '';
            
            // Clear from localStorage
            localStorage.removeItem('regexgen_input_text');
            
            // Update display
            renderTextWithWords('');
            
            // Clear any selections
            clearSelections();
            
            // Focus the textarea
            textInput.focus();
        };

        function loadPatterns() {
            const patterns = builder.get_patterns();
            const patternsList = document.getElementById('patternsList');
            
            patternsList.innerHTML = '';
            
            patterns.forEach((pattern, index) => {
                // Create pattern item for list
                const patternItem = document.createElement('div');
                patternItem.className = 'pattern-item';
                
                // Build visualization
                let vizHtml = '';
                if (pattern.type === 'Sequence') {
                    pattern.elements.forEach((element, idx) => {
                        if (element.type === 'Word') {
                            if (element.text.includes(' ')) {
                                vizHtml += `<span class="pattern-element-small pattern-phrase">"${escapeHtml(element.text)}"</span>`;
                            } else {
                                vizHtml += `<span class="pattern-element-small pattern-word">${escapeHtml(element.text)}</span>`;
                            }
                        } else if (element.type === 'Gap') {
                            if (element.min_words === 0 && !element.max_words) {
                                // This is an AND connector
                                if (idx > 0 && idx < pattern.elements.length - 1) {
                                    vizHtml += `<span class="pattern-element-small pattern-and">AND</span>`;
                                }
                            } else {
                                const gapText = element.max_words ? `${element.min_words}-${element.max_words}` : `${element.min_words}+`;
                                vizHtml += `<span class="pattern-element-small pattern-gap">gap(${gapText})</span>`;
                            }
                        }
                    });
                }
                
                const regex = patternToRegex(pattern);
                
                patternItem.innerHTML = `
                    <div class="pattern-name">${escapeHtml(pattern.name)}</div>
                    <div class="pattern-visualization">${vizHtml}</div>
                    <div class="pattern-regex">${escapeHtml(regex)}</div>
                    <div class="pattern-actions">
                        <button class="button-small button-secondary" onclick="window.testPattern(${index})">Test</button>
                        <button class="button-small button-danger" onclick="window.deletePattern(${index})">Delete</button>
                    </div>
                `;
                patternsList.appendChild(patternItem);
            });
        }

        function patternToRegex(pattern) {
            // This is a simplified version - the real regex is generated in Rust
            if (pattern.type === 'Sequence') {
                let parts = [];
                pattern.elements.forEach(element => {
                    if (element.type === 'Word') {
                        parts.push(`\\b${escapeRegex(element.text)}\\b`);
                    } else if (element.type === 'Gap') {
                        if (element.min_words === 0 && !element.max_words) {
                            parts.push('.*?');
                        } else {
                            parts.push(`(?:\\W+\\w+){${element.min_words},${element.max_words || ''}}`);
                        }
                    }
                });
                return parts.join('');
            }
            return '';
        }

        function escapeRegex(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        window.testPattern = function(index) {
            const text = document.getElementById('textInput').value;
            
            if (!text) {
                showStatus('Please enter some text to test against', 'error');
                document.getElementById('testResults').style.display = 'none';
                return;
            }
            
            const matches = builder.test_pattern(index, text);
            const patterns = builder.get_patterns();
            const pattern = patterns[index];
            
            if (matches && matches.length > 0) {
                showStatus(`Found ${matches.length} match${matches.length > 1 ? 'es' : ''} for "${pattern.name}"`, 'success');
                highlightMatches(text, matches);
                document.getElementById('testResults').style.display = 'block';
            } else {
                showStatus(`No matches found for "${pattern.name}"`, 'error');
                document.getElementById('testResults').style.display = 'none';
            }
        };

        window.deletePattern = function(index) {
            if (confirm('Are you sure you want to delete this pattern?')) {
                try {
                    builder.delete_pattern(index);
                    loadPatterns();
                    showStatus('Pattern deleted successfully', 'success');
                } catch (error) {
                    showStatus('Error deleting pattern', 'error');
                }
            }
        };

        function highlightMatches(text, matches) {
            const contentEl = document.getElementById('testResultsContent');
            
            let highlightedText = text;
            let offset = 0;
            
            matches.forEach(([start, end]) => {
                const beforeMatch = highlightedText.substring(0, start + offset);
                const match = highlightedText.substring(start + offset, end + offset);
                const afterMatch = highlightedText.substring(end + offset);
                
                const highlightedMatch = `<span class="match-highlight">${escapeHtml(match)}</span>`;
                highlightedText = beforeMatch + highlightedMatch + afterMatch;
                offset += highlightedMatch.length - match.length;
            });
            
            contentEl.innerHTML = `<pre style="white-space: pre-wrap; font-family: monospace; line-height: 1.6; margin: 0;">${highlightedText}</pre>`;
        }

        function showStatus(message, type) {
            const statusEl = document.getElementById('statusMessage');
            statusEl.textContent = message;
            statusEl.className = `status-message status-${type}`;
            statusEl.style.display = 'block';
            
            // Don't auto-hide for test results
            if (!message.includes('match')) {
                setTimeout(() => {
                    statusEl.style.display = 'none';
                }, 3000);
            }
        }

        function escapeHtml(text) {
            // First escape HTML entities
            const escaped = text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#039;');
            
            // Then preserve whitespace
            return escaped
                .replace(/ {2}/g, ' &nbsp;')  // Preserve multiple spaces
                .replace(/\t/g, '&nbsp;&nbsp;&nbsp;&nbsp;')  // Preserve tabs
                .replace(/\n/g, '<br>');  // Preserve line breaks
        }

        // Tab Management
        window.switchTab = function(tabName) {
            currentTab = tabName;
            
            // Update tab buttons
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Update tab panels
            document.querySelectorAll('.tab-panel').forEach(panel => {
                panel.classList.remove('active');
            });
            document.getElementById(tabName + 'Tab').classList.add('active');
            
            // Update instructions
            const instructionText = document.getElementById('instructionText');
            if (tabName === 'patterns') {
                instructionText.textContent = 'Click words to select them. Adjacent selections become phrases. Non-adjacent selections create AND patterns that match both parts with anything in between.';
                // Clear selections when switching to patterns
                clearSelections();
            } else if (tabName === 'topics') {
                instructionText.textContent = 'Select patterns below and choose AND or NOT to combine them into topics. Topics match text that satisfies all AND patterns while excluding NOT patterns.';
                loadPatternSelector();
            } else if (tabName === 'export') {
                instructionText.textContent = 'Select topics to export. The export will include both the composed regex and the component patterns for maximum flexibility.';
                loadExportableTopics();
            }
        };

        // Topic Management
        function loadPatternSelector() {
            const patterns = builder.get_patterns();
            const selector = document.getElementById('patternsSelector');
            selector.innerHTML = '';
            
            patterns.forEach((pattern, index) => {
                if (pattern.type === 'Sequence') { // Only show sequence patterns, not existing topics
                    const card = document.createElement('div');
                    card.className = 'pattern-selector-card';
                    if (selectedPatternsForTopic.has(pattern.id)) {
                        card.classList.add('selected');
                    }
                    
                    // Build pattern visualization
                    let vizHtml = '';
                    pattern.elements.forEach((element, idx) => {
                        if (element.type === 'Word') {
                            if (element.text.includes(' ')) {
                                vizHtml += `<span class="pattern-element-small pattern-phrase">"${escapeHtml(element.text)}"</span>`;
                            } else {
                                vizHtml += `<span class="pattern-element-small pattern-word">${escapeHtml(element.text)}</span>`;
                            }
                        } else if (element.type === 'Gap') {
                            if (element.min_words === 0 && !element.max_words) {
                                if (idx > 0 && idx < pattern.elements.length - 1) {
                                    vizHtml += `<span class="pattern-element-small pattern-and">AND</span>`;
                                }
                            }
                        }
                    });
                    
                    const selectedData = selectedPatternsForTopic.get(pattern.id);
                    const currentOperator = selectedData ? selectedData.operator : 'AND';
                    
                    card.innerHTML = `
                        <div onclick="window.selectPatternForTopic('${pattern.id}', ${index})">
                            <div class="pattern-name">${escapeHtml(pattern.name)}</div>
                            <div class="pattern-visualization">${vizHtml}</div>
                        </div>
                        <div class="pattern-operator-buttons" onclick="event.stopPropagation()">
                            <button class="operator-button ${currentOperator === 'AND' ? 'active-and' : ''}" 
                                    onclick="window.setPatternOperator('${pattern.id}', 'AND')" type="button">AND</button>
                            <button class="operator-button ${currentOperator === 'NOT' ? 'active-not' : ''}" 
                                    onclick="window.setPatternOperator('${pattern.id}', 'NOT')" type="button">NOT</button>
                        </div>
                    `;
                    
                    selector.appendChild(card);
                }
            });
        }

        window.selectPatternForTopic = function(patternId, patternIndex) {
            const patterns = builder.get_patterns();
            const pattern = patterns[patternIndex];
            
            if (selectedPatternsForTopic.has(patternId)) {
                selectedPatternsForTopic.delete(patternId);
            } else {
                selectedPatternsForTopic.set(patternId, {
                    pattern: pattern,
                    operator: 'AND',
                    index: patternIndex
                });
            }
            
            loadPatternSelector();
            updateTopicBuilder();
        };

        window.setPatternOperator = function(patternId, operator) {
            if (selectedPatternsForTopic.has(patternId)) {
                selectedPatternsForTopic.get(patternId).operator = operator;
                loadPatternSelector();
                updateTopicBuilder();
            }
        };

        function updateTopicBuilder() {
            const builderEl = document.getElementById('topicBuilder');
            const previewEl = document.getElementById('selectedPatternsPreview');
            
            if (selectedPatternsForTopic.size === 0) {
                previewEl.innerHTML = '<span style="color: #999;">Select patterns above to build a topic...</span>';
                return;
            }
            
            previewEl.innerHTML = '';
            
            selectedPatternsForTopic.forEach(({pattern, operator}) => {
                const item = document.createElement('span');
                item.className = `selected-pattern-item selected-pattern-${operator.toLowerCase()}`;
                item.textContent = `${operator === 'NOT' ? 'NOT ' : ''}${pattern.name}`;
                previewEl.appendChild(item);
            });
        }

        window.saveTopic = async function() {
            const topicName = document.getElementById('topicName').value.trim();
            
            if (!topicName) {
                showTopicStatus('Please enter a topic name', 'error');
                return;
            }
            
            if (selectedPatternsForTopic.size === 0) {
                showTopicStatus('Please select at least one pattern', 'error');
                return;
            }
            
            try {
                // Create composite pattern
                const patternIndices = [];
                const operators = [];
                
                selectedPatternsForTopic.forEach(({index, operator}) => {
                    patternIndices.push(index);
                    operators.push(operator);
                });
                
                // Create topic by storing composite pattern directly
                const topicData = {
                    type: 'Composite',
                    id: Date.now() + '-' + Math.random(),
                    name: topicName,
                    operator: 'And',
                    patterns: []
                };
                
                selectedPatternsForTopic.forEach(({pattern, operator}) => {
                    if (operator === 'NOT') {
                        topicData.patterns.push({
                            type: 'Composite',
                            id: Date.now() + '-' + Math.random(),
                            name: `NOT ${pattern.name}`,
                            operator: 'Not',
                            patterns: [pattern]
                        });
                    } else {
                        topicData.patterns.push(pattern);
                    }
                });
                
                // Save to storage
                const topics = getTopicsFromStorage();
                topics.push(topicData);
                saveTopicsToStorage(topics);
                
                showTopicStatus(`Topic "${topicName}" created successfully!`, 'success');
                
                document.getElementById('topicName').value = '';
                clearTopicBuilder();
                loadTopics();
            } catch (error) {
                showTopicStatus('Error creating topic: ' + error, 'error');
            }
        };

        window.clearTopicBuilder = function() {
            selectedPatternsForTopic.clear();
            loadPatternSelector();
            updateTopicBuilder();
        };

        function loadTopics() {
            const topics = getTopicsFromStorage();
            const topicsList = document.getElementById('topicsList');
            
            topicsList.innerHTML = '';
            
            topics.forEach((topic, index) => {
                const topicItem = document.createElement('div');
                topicItem.className = 'topic-item';
                
                // List patterns in topic
                let patternsText = '';
                if (topic.patterns) {
                    patternsText = topic.patterns.map(p => {
                        if (p.type === 'Composite' && p.operator === 'Not') {
                            return `NOT ${p.patterns[0].name}`;
                        }
                        return p.name;
                    }).join(', ');
                }
                
                topicItem.innerHTML = `
                    <div class="topic-name">${escapeHtml(topic.name)}</div>
                    <div class="topic-patterns">${escapeHtml(patternsText)}</div>
                    <div class="pattern-actions">
                        <button class="button-small button-secondary" onclick="window.testTopic(${index})">Test</button>
                        <button class="button-small button-danger" onclick="window.deleteTopic(${index})">Delete</button>
                    </div>
                `;
                
                topicsList.appendChild(topicItem);
            });
        }

        window.testTopic = function(index) {
            const text = document.getElementById('textInput').value;
            
            if (!text) {
                showTopicStatus('Please enter some text to test against', 'error');
                document.getElementById('topicTestResults').style.display = 'none';
                return;
            }
            
            const topics = getTopicsFromStorage();
            const topic = topics[index];
            
            // Test each pattern in the topic
            let allAndPatternsMatch = true;
            let anyNotPatternMatches = false;
            let matchDetails = [];
            
            topic.patterns.forEach(pattern => {
                let isNotPattern = false;
                let testPattern = pattern;
                
                // Check if this is a NOT pattern
                if (pattern.type === 'Composite' && pattern.operator === 'Not' && pattern.patterns.length > 0) {
                    isNotPattern = true;
                    testPattern = pattern.patterns[0];
                }
                
                // Create regex for the pattern
                let regex;
                try {
                    const regexStr = patternToRegex(testPattern);
                    regex = new RegExp(regexStr, 'i');
                    const matches = regex.test(text);
                    
                    if (isNotPattern) {
                        if (matches) {
                            anyNotPatternMatches = true;
                            matchDetails.push(`❌ NOT ${testPattern.name}: Found (should not match)`);
                        } else {
                            matchDetails.push(`✅ NOT ${testPattern.name}: Not found (correct)`);
                        }
                    } else {
                        if (matches) {
                            matchDetails.push(`✅ ${testPattern.name}: Found`);
                        } else {
                            allAndPatternsMatch = false;
                            matchDetails.push(`❌ ${testPattern.name}: Not found`);
                        }
                    }
                } catch (e) {
                    matchDetails.push(`⚠️ ${testPattern.name}: Error testing pattern`);
                }
            });
            
            // Topic matches if all AND patterns match and no NOT patterns match
            const topicMatches = allAndPatternsMatch && !anyNotPatternMatches;
            
            if (topicMatches) {
                showTopicStatus(`✅ Topic "${topic.name}" matches!`, 'success');
            } else {
                showTopicStatus(`❌ Topic "${topic.name}" does not match`, 'error');
            }
            
            // Show detailed results
            document.getElementById('topicTestResults').style.display = 'block';
            document.getElementById('topicTestResultsContent').innerHTML = `
                <div style="margin-bottom: 1rem;">
                    <strong>Pattern Results:</strong>
                </div>
                <pre style="margin: 0; line-height: 1.6;">${matchDetails.join('\n')}</pre>
            `;
        };

        window.deleteTopic = function(index) {
            if (confirm('Are you sure you want to delete this topic?')) {
                const topics = getTopicsFromStorage();
                topics.splice(index, 1);
                saveTopicsToStorage(topics);
                loadTopics();
                showTopicStatus('Topic deleted successfully', 'success');
            }
        };

        function showTopicStatus(message, type) {
            const statusEl = document.getElementById('topicStatusMessage');
            statusEl.textContent = message;
            statusEl.className = `status-message status-${type}`;
            statusEl.style.display = 'block';
            
            if (!message.includes('Testing')) {
                setTimeout(() => {
                    statusEl.style.display = 'none';
                }, 3000);
            }
        }

        // Storage functions for topics
        function getTopicsFromStorage() {
            try {
                const json = localStorage.getItem('regexgen_topics');
                return json ? JSON.parse(json) : [];
            } catch {
                return [];
            }
        }

        function saveTopicsToStorage(topics) {
            localStorage.setItem('regexgen_topics', JSON.stringify(topics));
        }

        // Export functionality
        function loadExportableTopics() {
            const topics = getTopicsFromStorage();
            const exportList = document.getElementById('exportableTopicsList');
            
            exportList.innerHTML = '';
            selectedTopicsForExport.clear();
            
            topics.forEach((topic, index) => {
                const item = document.createElement('div');
                item.className = 'export-topic-item';
                item.onclick = () => toggleTopicSelection(index);
                
                // List patterns in topic
                let patternsText = '';
                if (topic.patterns) {
                    patternsText = topic.patterns.map(p => {
                        if (p.type === 'Composite' && p.operator === 'Not') {
                            return `NOT ${p.patterns[0].name}`;
                        }
                        return p.name;
                    }).join(', ');
                }
                
                item.innerHTML = `
                    <span style="font-weight: 600;">${escapeHtml(topic.name)}</span>
                    <div style="font-size: 12px; color: #666; margin-top: 0.25rem;">${escapeHtml(patternsText)}</div>
                `;
                
                exportList.appendChild(item);
            });
            
            updateExportPreview();
        }

        function toggleTopicSelection(index) {
            const item = document.querySelectorAll('.export-topic-item')[index];
            
            if (selectedTopicsForExport.has(index)) {
                selectedTopicsForExport.delete(index);
                item.classList.remove('selected');
            } else {
                selectedTopicsForExport.add(index);
                item.classList.add('selected');
            }
            
            updateExportButton();
            updateExportPreview();
        }

        window.selectAllTopics = function() {
            const topics = getTopicsFromStorage();
            const items = document.querySelectorAll('.export-topic-item');
            
            selectedTopicsForExport.clear();
            topics.forEach((_, index) => {
                selectedTopicsForExport.add(index);
                if (items[index]) {
                    items[index].classList.add('selected');
                }
            });
            
            updateExportButton();
            updateExportPreview();
        };

        window.deselectAllTopics = function() {
            selectedTopicsForExport.clear();
            document.querySelectorAll('.export-topic-item').forEach(item => {
                item.classList.remove('selected');
            });
            
            updateExportButton();
            updateExportPreview();
        };

        function updateExportButton() {
            const exportButton = document.getElementById('exportButton');
            exportButton.disabled = selectedTopicsForExport.size === 0;
        }

        function updateExportPreview() {
            const topics = getTopicsFromStorage();
            const exportData = {
                topics: []
            };
            
            selectedTopicsForExport.forEach(index => {
                const topic = topics[index];
                if (topic) {
                    const exportTopic = {
                        name: topic.name,
                        composed_regex: composeTopicRegex(topic),
                        components: []
                    };
                    
                    topic.patterns.forEach(pattern => {
                        if (pattern.type === 'Composite' && pattern.operator === 'Not') {
                            const innerPattern = pattern.patterns[0];
                            exportTopic.components.push({
                                pattern: innerPattern.name,
                                operator: 'NOT',
                                regex: patternToRegex(innerPattern)
                            });
                        } else {
                            exportTopic.components.push({
                                pattern: pattern.name,
                                operator: 'AND',
                                regex: patternToRegex(pattern)
                            });
                        }
                    });
                    
                    exportData.topics.push(exportTopic);
                }
            });
            
            currentExportData = exportData;
            
            const previewEl = document.getElementById('exportPreview');
            if (exportData.topics.length > 0) {
                previewEl.innerHTML = `<pre style="margin: 0;">${escapeHtml(JSON.stringify(exportData, null, 2))}</pre>`;
            } else {
                previewEl.innerHTML = '<span style="color: #999;">Select topics to see export preview...</span>';
            }
        }

        function composeTopicRegex(topic) {
            // Compose a single regex from all patterns
            const andPatterns = [];
            const notPatterns = [];
            
            topic.patterns.forEach(pattern => {
                if (pattern.type === 'Composite' && pattern.operator === 'Not' && pattern.patterns.length > 0) {
                    // Get the inner pattern from NOT wrapper
                    const innerPattern = pattern.patterns[0];
                    const regex = patternToRegex(innerPattern);
                    notPatterns.push(regex);
                } else {
                    const regex = patternToRegex(pattern);
                    andPatterns.push(regex);
                }
            });
            
            let composed = '^';
            
            // Add positive lookaheads for AND patterns
            andPatterns.forEach(regex => {
                composed += `(?=.*${regex})`;
            });
            
            // Add negative lookaheads for NOT patterns
            notPatterns.forEach(regex => {
                composed += `(?!.*${regex})`;
            });
            
            composed += '.*$';
            
            return composed;
        }

        window.exportSelectedTopics = function() {
            if (!currentExportData || currentExportData.topics.length === 0) {
                return;
            }
            
            const dataStr = JSON.stringify(currentExportData, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(dataBlob);
            link.download = `regexgen-topics-${new Date().toISOString().slice(0, 10)}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        };

        window.copyExportToClipboard = function() {
            if (!currentExportData || currentExportData.topics.length === 0) {
                return;
            }
            
            const dataStr = JSON.stringify(currentExportData, null, 2);
            navigator.clipboard.writeText(dataStr).then(() => {
                alert('Export data copied to clipboard!');
            }).catch(err => {
                console.error('Failed to copy to clipboard:', err);
            });
        };

        window.filterExportTopics = function() {
            const searchText = document.getElementById('topicSearch').value.toLowerCase();
            const items = document.querySelectorAll('.export-topic-item');
            
            items.forEach(item => {
                const text = item.textContent.toLowerCase();
                if (text.includes(searchText)) {
                    item.style.display = 'block';
                } else {
                    item.style.display = 'none';
                }
            });
        };

        run();
    </script>
</body>
</html>