<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RegexGen - Pattern Builder</title>
    <!-- Ready for Topics: Collections of patterns will be added as a new panel -->
    <style>
        :root {
            --verint-blue: #0066CC;
            --verint-light-blue: #E6F2FF;
            --verint-dark-blue: #004499;
            --verint-gray: #666666;
            --verint-light-gray: #F5F5F5;
            --accent-green: #28a745;
            --accent-orange: #fd7e14;
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f8f9fa;
            color: #333;
        }

        .header {
            background-color: var(--verint-blue);
            color: white;
            padding: 1rem 2rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            margin: 0;
            font-size: 1.5rem;
            font-weight: 500;
        }

        .selection-mode {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .selection-mode label {
            color: white;
            margin: 0;
        }

        .mode-toggle {
            display: flex;
            background: rgba(255,255,255,0.2);
            border-radius: 4px;
            padding: 2px;
        }

        .mode-toggle button {
            background: none;
            border: none;
            color: white;
            padding: 0.5rem 1rem;
            cursor: pointer;
            border-radius: 2px;
            transition: background 0.2s;
        }

        .mode-toggle button.active {
            background: white;
            color: var(--verint-blue);
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 2rem;
            display: grid;
            grid-template-columns: 1fr 500px;
            gap: 2rem;
        }

        .main-panel {
            background: white;
            border-radius: 8px;
            padding: 1.5rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .side-panel {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .panel {
            background: white;
            border-radius: 8px;
            padding: 1.5rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .panel-header {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--verint-dark-blue);
        }

        #textInput {
            width: 100%;
            min-height: 400px;
            padding: 1rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            resize: vertical;
            transition: border-color 0.2s;
            line-height: 1.6;
            white-space: pre-wrap;
            position: relative;
        }

        #textInput:focus {
            outline: none;
            border-color: var(--verint-blue);
        }

        .text-display {
            position: relative;
            min-height: 400px;
            padding: 1rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            line-height: 1.6;
            background: #fafafa;
            cursor: text;
            user-select: none;
            overflow-y: auto;
            max-height: 600px;
        }

        .edit-button {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            padding: 0.25rem 0.75rem;
            font-size: 12px;
            background: white;
            border: 1px solid var(--verint-blue);
            color: var(--verint-blue);
            cursor: pointer;
            border-radius: 4px;
        }

        .edit-button:hover {
            background: var(--verint-light-blue);
        }

        .word-span {
            padding: 2px;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-block;
            position: relative;
        }

        .word-span:hover {
            background-color: #e0e0e0;
            border-radius: 3px;
        }

        .word-span.selected {
            background-color: var(--verint-light-blue);
            border-radius: 3px;
            font-weight: 600;
        }

        .phrase-selection {
            background-color: var(--verint-light-blue);
            border-radius: 3px;
            font-weight: 600;
            padding: 2px 4px;
            position: relative;
            display: inline;
        }

        .phrase-selection::after {
            content: "âœ“";
            position: absolute;
            top: -18px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--accent-green);
            color: white;
            padding: 2px 6px;
            border-radius: 50%;
            font-size: 12px;
            font-weight: bold;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .word-span.in-phrase {
            background-color: transparent;
            font-weight: inherit;
        }

        .pattern-preview {
            margin-top: 1rem;
            padding: 1rem;
            background-color: #f8f9fa;
            border-radius: 4px;
            min-height: 60px;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .pattern-element {
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 500;
        }

        .pattern-word {
            background-color: var(--verint-blue);
            color: white;
        }

        .pattern-gap {
            background-color: var(--accent-orange);
            color: white;
            font-style: italic;
        }

        .pattern-phrase {
            background-color: var(--verint-dark-blue);
            color: white;
        }

        .pattern-and {
            background-color: transparent;
            color: var(--verint-gray);
            border: 2px solid var(--verint-gray);
            font-weight: bold;
            font-size: 12px;
        }

        .controls {
            margin-top: 1rem;
            display: flex;
            gap: 1rem;
            align-items: flex-end;
        }

        .input-group {
            flex: 1;
        }

        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: var(--verint-gray);
        }

        input[type="text"] {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            transition: border-color 0.2s;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: var(--verint-blue);
        }

        button {
            background-color: var(--verint-blue);
            color: white;
            border: none;
            padding: 0.5rem 1.5rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background-color 0.2s;
        }

        button:hover {
            background-color: var(--verint-dark-blue);
        }

        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        .button-secondary {
            background-color: white;
            color: var(--verint-blue);
            border: 1px solid var(--verint-blue);
        }

        .button-secondary:hover {
            background-color: var(--verint-light-blue);
        }

        .patterns-list {
            max-height: 400px;
            overflow-y: auto;
        }

        .pattern-item {
            padding: 1rem;
            border: 1px solid #eee;
            border-radius: 4px;
            margin-bottom: 0.75rem;
            transition: all 0.2s;
        }

        .pattern-item:hover {
            background-color: var(--verint-light-gray);
            border-color: var(--verint-blue);
        }

        .pattern-name {
            font-weight: 600;
            color: var(--verint-dark-blue);
            margin-bottom: 0.5rem;
        }

        .pattern-visualization {
            display: flex;
            flex-wrap: wrap;
            gap: 0.25rem;
            margin: 0.5rem 0;
        }

        .pattern-element-small {
            padding: 0.25rem 0.5rem;
            border-radius: 12px;
            font-size: 12px;
        }

        .pattern-regex {
            font-family: monospace;
            font-size: 12px;
            color: var(--verint-gray);
            margin-top: 0.5rem;
            padding: 0.5rem;
            background: #f5f5f5;
            border-radius: 4px;
            word-break: break-all;
        }

        .pattern-actions {
            margin-top: 0.5rem;
            display: flex;
            gap: 0.5rem;
        }

        .button-small {
            padding: 0.25rem 0.75rem;
            font-size: 12px;
        }

        .button-danger {
            background-color: #dc3545;
        }

        .button-danger:hover {
            background-color: #c82333;
        }

        .status-message {
            margin-bottom: 1rem;
            padding: 0.75rem;
            border-radius: 4px;
            font-size: 14px;
            display: none;
        }

        .status-success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status-error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .match-highlight {
            background-color: #FFEB3B;
            padding: 2px;
            border-radius: 2px;
            font-weight: bold;
        }

        .instructions {
            background: var(--verint-light-gray);
            padding: 1rem;
            border-radius: 4px;
            margin-bottom: 1rem;
            font-size: 14px;
        }

        .instructions h3 {
            margin-top: 0;
            color: var(--verint-dark-blue);
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>RegexGen - Pattern Builder</h1>
        <div class="selection-mode">
            <label>Selection Mode:</label>
            <div class="mode-toggle">
                <button id="modeWord" onclick="setMode('word')">Word</button>
                <button id="modeSequence" class="active" onclick="setMode('sequence')">Sequence</button>
            </div>
        </div>
    </div>

    <div class="container">
        <div class="main-panel">
            <div class="panel-header">Text Input</div>
            
            <div class="instructions">
                <h3>How to build patterns:</h3>
                <p><strong>Sequence Mode:</strong> Click words to select them. Pattern will match words in the order they appear in the text. Non-adjacent selections create automatic gaps.</p>
                <p><strong>Word Mode:</strong> Click multiple words to create an OR pattern (coming soon).</p>
            </div>

            <textarea id="textInput" placeholder="Paste or type your text here..."></textarea>
            <div id="textDisplay" class="text-display" style="display: none;">
                <span style="color: #999;">Paste or type your text here...</span>
            </div>
            
            <div class="pattern-preview" id="patternPreview">
                <span style="color: #999;">Your pattern will appear here as you select words...</span>
            </div>

            <div class="controls">
                <div class="input-group">
                    <label for="patternName">Pattern Name</label>
                    <input type="text" id="patternName" placeholder="Enter pattern name">
                </div>
                <button id="savePatternBtn" onclick="savePattern()">Save Pattern</button>
                <button class="button-secondary" onclick="clearSelections()">Clear Selections</button>
            </div>
        </div>

        <div class="side-panel">
            <div class="panel">
                <div class="panel-header">Saved Patterns</div>
                <div class="patterns-list" id="patternsList">
                    <!-- Patterns will be listed here -->
                </div>
            </div>

            <div class="panel">
                <div class="panel-header">Test Results</div>
                <div id="statusMessage" class="status-message"></div>
                <div id="testResults" style="display: none;">
                    <div id="testResultsContent"></div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        import init, { PatternBuilder, get_word_at_position, get_words_from_text } from './pkg/regexgen_rs.js';

        let builder;
        let currentMode = 'sequence';
        let wordElements = [];
        let selectedWords = [];

        async function run() {
            await init();
            builder = new PatternBuilder();
            setupTextInput();
            loadPatterns();
        }

        function setupTextInput() {
            const textInput = document.getElementById('textInput');
            const textDisplay = document.getElementById('textDisplay');
            
            // Update display when text changes
            textInput.addEventListener('input', (e) => {
                renderTextWithWords(e.target.value);
            });

            // Handle paste events
            textInput.addEventListener('paste', (e) => {
                setTimeout(() => {
                    renderTextWithWords(textInput.value);
                }, 0);
            });

            // Allow clicking on display to focus hidden textarea
            textDisplay.addEventListener('click', (e) => {
                if (e.target === textDisplay) {
                    textInput.focus();
                }
            });

            // Also handle paste on the display div
            textDisplay.addEventListener('paste', (e) => {
                e.preventDefault();
                const text = (e.clipboardData || window.clipboardData).getData('text');
                textInput.value = text;
                renderTextWithWords(text);
            });
        }

        function renderTextWithWords(text) {
            const textInput = document.getElementById('textInput');
            const textDisplay = document.getElementById('textDisplay');
            
            if (!text.trim()) {
                // Show textarea when empty
                textInput.style.display = 'block';
                textDisplay.style.display = 'none';
                return;
            }

            // Hide textarea and show display when there's text
            textInput.style.display = 'none';
            textDisplay.style.display = 'block';

            // Get all words with their positions
            const words = get_words_from_text(text);
            wordElements = words;
            
            // Group consecutive selections into phrases
            const selectedIndices = new Set(selectedWords.map(w => w.word_index));
            const phraseGroups = [];
            let currentPhrase = null;
            
            selectedWords.sort((a, b) => a.word_index - b.word_index).forEach(word => {
                if (currentPhrase && word.word_index === currentPhrase.endIndex + 1) {
                    // Extend current phrase
                    currentPhrase.endIndex = word.word_index;
                    currentPhrase.words.push(word);
                } else {
                    // Start new phrase
                    currentPhrase = {
                        startIndex: word.word_index,
                        endIndex: word.word_index,
                        words: [word]
                    };
                    phraseGroups.push(currentPhrase);
                }
            });
            
            // Build HTML with clickable words
            let html = '<button class="edit-button" onclick="window.editText()">Edit Text</button>';
            let lastEnd = 0;
            let inPhrase = false;
            let currentPhraseGroup = null;
            
            words.forEach((word, index) => {
                // Check if we're starting a phrase
                const phraseGroup = phraseGroups.find(p => p.startIndex === word.word_index);
                if (phraseGroup) {
                    currentPhraseGroup = phraseGroup;
                    inPhrase = true;
                    
                    // Add non-word text before phrase
                    if (word.start_index > lastEnd) {
                        html += escapeHtml(text.substring(lastEnd, word.start_index));
                    }
                    
                    // Start phrase span
                    html += '<span class="phrase-selection">';
                }
                
                // Add non-word text before this word (if not in phrase)
                if (!inPhrase && word.start_index > lastEnd) {
                    html += escapeHtml(text.substring(lastEnd, word.start_index));
                }
                
                // Add the word
                const isSelected = selectedIndices.has(word.word_index);
                const isInPhrase = inPhrase && currentPhraseGroup && word.word_index <= currentPhraseGroup.endIndex;
                
                if (isInPhrase) {
                    html += `<span class="word-span in-phrase" 
                             data-word-index="${word.word_index}"
                             onclick="window.handleWordClick(${word.word_index})">${escapeHtml(word.text)}</span>`;
                    
                    // Check if phrase ends
                    if (word.word_index === currentPhraseGroup.endIndex) {
                        // Add any trailing non-word text before closing phrase
                        const nextWord = words[index + 1];
                        if (nextWord && nextWord.start_index > word.end_index) {
                            html += escapeHtml(text.substring(word.end_index, nextWord.start_index));
                            lastEnd = nextWord.start_index;
                        }
                        html += '</span>'; // Close phrase span
                        inPhrase = false;
                        currentPhraseGroup = null;
                    } else {
                        // Add space between words in phrase
                        const nextWord = words[index + 1];
                        if (nextWord && word.end_index < nextWord.start_index) {
                            html += escapeHtml(text.substring(word.end_index, nextWord.start_index));
                            lastEnd = nextWord.start_index;
                        }
                    }
                } else {
                    html += `<span class="word-span ${isSelected && !isInPhrase ? 'selected' : ''}" 
                             data-word-index="${word.word_index}"
                             onclick="window.handleWordClick(${word.word_index})">${escapeHtml(word.text)}</span>`;
                }
                
                lastEnd = word.end_index;
            });
            
            // Add any remaining text
            if (lastEnd < text.length) {
                html += escapeHtml(text.substring(lastEnd));
            }
            
            textDisplay.innerHTML = html;
            textInput.value = text;
        }

        window.handleWordClick = function(wordIndex) {
            const word = wordElements[wordIndex];
            if (!word) return;
            
            if (currentMode === 'sequence') {
                // Check if word is already selected
                const existingIndex = selectedWords.findIndex(s => s.word_index === wordIndex);
                
                if (existingIndex >= 0) {
                    // If clicking on a selected word in a phrase, remove the entire phrase
                    const sortedWords = [...selectedWords].sort((a, b) => a.word_index - b.word_index);
                    let removeFrom = existingIndex;
                    let removeTo = existingIndex;
                    
                    // Find start of phrase
                    for (let i = existingIndex - 1; i >= 0; i--) {
                        if (sortedWords[i].word_index === sortedWords[i + 1].word_index - 1) {
                            removeFrom = i;
                        } else {
                            break;
                        }
                    }
                    
                    // Find end of phrase
                    for (let i = existingIndex + 1; i < sortedWords.length; i++) {
                        if (sortedWords[i].word_index === sortedWords[i - 1].word_index + 1) {
                            removeTo = i;
                        } else {
                            break;
                        }
                    }
                    
                    // Remove the phrase
                    const indicesToRemove = new Set();
                    for (let i = removeFrom; i <= removeTo; i++) {
                        indicesToRemove.add(sortedWords[i].word_index);
                    }
                    
                    selectedWords = selectedWords.filter(w => !indicesToRemove.has(w.word_index));
                    
                    // Clear selections from builder and re-add remaining
                    builder.clear_selections();
                    selectedWords.forEach(w => {
                        builder.add_selection(w.text, w.start_index, w.end_index, w.word_index);
                    });
                } else {
                    // Add new selection
                    selectedWords.push(word);
                    builder.add_selection(word.text, word.start_index, word.end_index, word.word_index);
                }
                
                // Re-render to update selection display
                renderTextWithWords(document.getElementById('textInput').value);
                updatePatternPreview();
            }
        };

        function updatePatternPreview() {
            const preview = builder.get_pattern_preview();
            const previewEl = document.getElementById('patternPreview');
            
            if (!preview || preview.length === 0) {
                previewEl.innerHTML = '<span style="color: #999;">Your pattern will appear here as you select words...</span>';
                return;
            }
            
            let html = '';
            preview.forEach((element, index) => {
                if (element.type === 'word') {
                    html += `<div class="pattern-element pattern-word">${escapeHtml(element.text)}</div>`;
                } else if (element.type === 'phrase') {
                    html += `<div class="pattern-element pattern-phrase">"${escapeHtml(element.text)}"</div>`;
                } else if (element.type === 'gap') {
                    const gapText = element.size === 1 ? '1 word' : `${element.size} words`;
                    html += `<div class="pattern-element pattern-gap">gap: ${gapText}</div>`;
                } else if (element.type === 'and') {
                    html += `<div class="pattern-element pattern-and">AND</div>`;
                }
            });
            
            previewEl.innerHTML = html;
        }

        window.savePattern = async function() {
            const patternName = document.getElementById('patternName').value.trim();
            
            if (!patternName) {
                showStatus('Please enter a pattern name', 'error');
                return;
            }
            
            if (selectedWords.length === 0) {
                showStatus('Please select at least one word', 'error');
                return;
            }
            
            try {
                const regex = await builder.build_sequence_pattern(patternName);
                showStatus(`Pattern "${patternName}" saved successfully!`, 'success');
                document.getElementById('patternName').value = '';
                selectedWords = [];
                renderTextWithWords(document.getElementById('textInput').value);
                updatePatternPreview();
                loadPatterns();
                // Hide test results when saving a new pattern
                document.getElementById('testResults').style.display = 'none';
            } catch (error) {
                showStatus('Error saving pattern: ' + error, 'error');
            }
        };

        window.clearSelections = function() {
            selectedWords = [];
            builder.clear_selections();
            renderTextWithWords(document.getElementById('textInput').value);
            updatePatternPreview();
        };

        window.editText = function() {
            const textInput = document.getElementById('textInput');
            const textDisplay = document.getElementById('textDisplay');
            
            textInput.style.display = 'block';
            textDisplay.style.display = 'none';
            textInput.focus();
            
            // Clear selections when editing
            clearSelections();
        };

        window.setMode = function(mode) {
            currentMode = mode;
            document.querySelectorAll('.mode-toggle button').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById('mode' + mode.charAt(0).toUpperCase() + mode.slice(1)).classList.add('active');
            clearSelections();
        };

        function loadPatterns() {
            const patterns = builder.get_patterns();
            const patternsList = document.getElementById('patternsList');
            
            patternsList.innerHTML = '';
            
            patterns.forEach((pattern, index) => {
                // Create pattern item for list
                const patternItem = document.createElement('div');
                patternItem.className = 'pattern-item';
                
                // Build visualization
                let vizHtml = '';
                if (pattern.type === 'Sequence') {
                    pattern.elements.forEach((element, idx) => {
                        if (element.type === 'Word') {
                            if (element.text.includes(' ')) {
                                vizHtml += `<span class="pattern-element-small pattern-phrase">"${escapeHtml(element.text)}"</span>`;
                            } else {
                                vizHtml += `<span class="pattern-element-small pattern-word">${escapeHtml(element.text)}</span>`;
                            }
                        } else if (element.type === 'Gap') {
                            if (element.min_words === 0 && !element.max_words) {
                                // This is an AND connector
                                if (idx > 0 && idx < pattern.elements.length - 1) {
                                    vizHtml += `<span class="pattern-element-small pattern-and">AND</span>`;
                                }
                            } else {
                                const gapText = element.max_words ? `${element.min_words}-${element.max_words}` : `${element.min_words}+`;
                                vizHtml += `<span class="pattern-element-small pattern-gap">gap(${gapText})</span>`;
                            }
                        }
                    });
                }
                
                const regex = patternToRegex(pattern);
                
                patternItem.innerHTML = `
                    <div class="pattern-name">${escapeHtml(pattern.name)}</div>
                    <div class="pattern-visualization">${vizHtml}</div>
                    <div class="pattern-regex">${escapeHtml(regex)}</div>
                    <div class="pattern-actions">
                        <button class="button-small button-secondary" onclick="window.testPattern(${index})">Test</button>
                        <button class="button-small button-danger" onclick="window.deletePattern(${index})">Delete</button>
                    </div>
                `;
                patternsList.appendChild(patternItem);
            });
        }

        function patternToRegex(pattern) {
            // This is a simplified version - the real regex is generated in Rust
            if (pattern.type === 'Sequence') {
                let parts = [];
                pattern.elements.forEach(element => {
                    if (element.type === 'Word') {
                        parts.push(`\\b${escapeRegex(element.text)}\\b`);
                    } else if (element.type === 'Gap') {
                        if (element.min_words === 0 && !element.max_words) {
                            parts.push('.*?');
                        } else {
                            parts.push(`(?:\\W+\\w+){${element.min_words},${element.max_words || ''}}`);
                        }
                    }
                });
                return parts.join('');
            }
            return '';
        }

        function escapeRegex(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        window.testPattern = function(index) {
            const text = document.getElementById('textInput').value;
            
            if (!text) {
                showStatus('Please enter some text to test against', 'error');
                document.getElementById('testResults').style.display = 'none';
                return;
            }
            
            const matches = builder.test_pattern(index, text);
            const patterns = builder.get_patterns();
            const pattern = patterns[index];
            
            if (matches && matches.length > 0) {
                showStatus(`Found ${matches.length} match${matches.length > 1 ? 'es' : ''} for "${pattern.name}"`, 'success');
                highlightMatches(text, matches);
                document.getElementById('testResults').style.display = 'block';
            } else {
                showStatus(`No matches found for "${pattern.name}"`, 'error');
                document.getElementById('testResults').style.display = 'none';
            }
        };

        window.deletePattern = function(index) {
            if (confirm('Are you sure you want to delete this pattern?')) {
                try {
                    builder.delete_pattern(index);
                    loadPatterns();
                    showStatus('Pattern deleted successfully', 'success');
                } catch (error) {
                    showStatus('Error deleting pattern', 'error');
                }
            }
        };

        function highlightMatches(text, matches) {
            const contentEl = document.getElementById('testResultsContent');
            
            let highlightedText = text;
            let offset = 0;
            
            matches.forEach(([start, end]) => {
                const beforeMatch = highlightedText.substring(0, start + offset);
                const match = highlightedText.substring(start + offset, end + offset);
                const afterMatch = highlightedText.substring(end + offset);
                
                const highlightedMatch = `<span class="match-highlight">${escapeHtml(match)}</span>`;
                highlightedText = beforeMatch + highlightedMatch + afterMatch;
                offset += highlightedMatch.length - match.length;
            });
            
            contentEl.innerHTML = `<pre style="white-space: pre-wrap; font-family: monospace; line-height: 1.6; margin: 0;">${highlightedText}</pre>`;
        }

        function showStatus(message, type) {
            const statusEl = document.getElementById('statusMessage');
            statusEl.textContent = message;
            statusEl.className = `status-message status-${type}`;
            statusEl.style.display = 'block';
            
            // Don't auto-hide for test results
            if (!message.includes('match')) {
                setTimeout(() => {
                    statusEl.style.display = 'none';
                }, 3000);
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        run();
    </script>
</body>
</html>